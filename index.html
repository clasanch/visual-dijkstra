<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Algoritmos de Caminos - Tres Algoritmos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to right, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 900px;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(4px);
        }
        
        .instructions {
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .instructions p {
            margin-bottom: 8px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 15px 0;
            font-size: 0.85rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #3498db, #1a5276);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #1a5276, #3498db);
        }
        
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .grid-container {
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 100%;
            height: 400px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(40, 1fr);
            grid-template-rows: repeat(40, 1fr);
            width: 100%;
            height: 100%;
            gap: 1px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .cell {
            background: #2c3e50;
            transition: all 0.1s ease;
        }
        
        .cell.start {
            background: #2ecc71;
            box-shadow: 0 0 10px #2ecc71;
        }
        
        .cell.end {
            background: #e74c3c;
            box-shadow: 0 0 10px #e74c3c;
        }
        
        .cell.wall {
            background: #34495e;
        }
        
        .cell.visited {
            background: #3498db;
        }
        
        .cell.path {
            background: #9b59b6;
            animation: pulse 1.5s infinite;
        }
        
        .cell.visited.dijkstra {
            background: #1abc9c;
        }
        
        .cell.visited.astar {
            background: #f1c40f;
        }
        
        .cell.visited.enhanced {
            background: #ff6b6b;
        }
        
        .cell.path.dijkstra {
            background: #8e44ad;
        }
        
        .cell.path.astar {
            background: #e67e22;
        }
        
        .cell.path.enhanced {
            background: #4ecdc4;
        }
        
        .results {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            gap: 15px;
        }
        
        .algo-result {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        
        .algo-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .stats {
            font-size: 0.95rem;
            margin-bottom: 5px;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .speed-control input {
            flex: 1;
        }
        
        .winner {
            animation: winnerPulse 1.5s infinite;
        }
        
        @keyframes winnerPulse {
            0% { box-shadow: 0 0 5px #fff; }
            50% { box-shadow: 0 0 20px #ffdd00; }
            100% { box-shadow: 0 0 5px #fff; }
        }
        
        .comparison {
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            margin-top: 20px;
            min-height: 40px;
        }
        
        footer {
            margin-top: 30px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        .explanation {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .explanation p {
            margin-bottom: 10px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <header>
        <h1>Visualizador de Algoritmos de Caminos</h1>
        <div class="subtitle">Dijkstra vs A* vs BMSSP - Comparación en tiempo real</div>
    </header>
    
    <div class="container">
        <div class="control-panel">
            <div class="instructions">
                <p><strong>Instrucciones:</strong></p>
                <p>1. Selecciona el punto de inicio (clic izquierdo) y destino (clic derecho)</p>
                <p>2. Dibuja obstáculos manteniendo presionado el ratón</p>
                <p>3. Haz clic en "Iniciar Visualización" para ver los tres algoritmos en acción</p>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2ecc71;"></div>
                    <span>Inicio</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                    <span>Destino</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #34495e;"></div>
                    <span>Obstáculo</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #1abc9c;"></div>
                    <span>Dijkstra</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f1c40f;"></div>
                    <span>A*</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff6b6b;"></div>
                    <span>Enhanced</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #8e44ad;"></div>
                    <span>Camino Dijkstra</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e67e22;"></div>
                    <span>Camino A*</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4ecdc4;"></div>
                    <span>Camino Enhanced</span>
                </div>
            </div>
            
            <div class="controls">
                <button id="startBtn">Iniciar Visualización</button>
                <button id="clearBtn">Limpiar Todo</button>
                <button id="clearWallsBtn">Limpiar Obstáculos</button>
                <button id="randomBtn">Obstáculos Aleatorios</button>
            </div>
            
            <div class="speed-control">
                <span>Velocidad:</span>
                <input type="range" id="speedSlider" min="1" max="20" value="15">
                <span id="speedValue">Rápido</span>
            </div>
        </div>
        
        <div class="grid-container">
            <div class="grid" id="grid"></div>
        </div>
        
        <div class="comparison" id="comparison"></div>
        
        <div class="results">
            <div class="algo-result" id="dijkstraResult">
                <div class="algo-title">Dijkstra Clásico</div>
                <div class="stats">Tiempo: <span id="dijkstraTime">0 ms</span></div>
                <div class="stats">Visitadas: <span id="dijkstraVisited">0</span></div>
                <div class="stats">Longitud: <span id="dijkstraLength">0</span></div>
            </div>
            
            <div class="algo-result" id="astarResult">
                <div class="algo-title">A* Search</div>
                <div class="stats">Tiempo: <span id="astarTime">0 ms</span></div>
                <div class="stats">Visitadas: <span id="astarVisited">0</span></div>
                <div class="stats">Longitud: <span id="astarLength">0</span></div>
            </div>
            
            <div class="algo-result" id="enhancedResult">
                <div class="algo-title">BMSSP</div>
                <div class="stats">Tiempo: <span id="enhancedTime">0 ms</span></div>
                <div class="stats">Visitadas: <span id="enhancedVisited">0</span></div>
                <div class="stats">Longitud: <span id="enhancedLength">0</span></div>
            </div>
        </div>
        
        <div class="explanation">
            <p><strong>BMSSP (Basado en arXiv:2504.17033):</strong> Usa bucketing logarítmico y exploración por regiones para reducir las operaciones de heap, logrando complejidad O(m log^(2/3) n) vs O(m log n) del Dijkstra clásico.</p>
            <p><strong>Nota:</strong> En grids pequeños la diferencia puede ser mínima, pero se aprecia mejor en laberintos complejos con muchos obstáculos.</p>
        </div>
    </div>
    
    <footer>
        <p>Visualización de tres algoritmos de búsqueda de caminos | BMSSP basado en investigación de 2025</p>
    </footer>

    <script>
        // Configuración
        const ROWS = 40;
        const COLS = 40;
        const START_COLOR = '#2ecc71';
        const END_COLOR = '#e74c3c';
        const WALL_COLOR = '#34495e';
        const VISITED_DIJKSTRA = '#1abc9c';
        const VISITED_ASTAR = '#f1c40f';
        const VISITED_ENHANCED = '#ff6b6b';
        const PATH_DIJKSTRA = '#8e44ad';
        const PATH_ASTAR = '#e67e22';
        const PATH_ENHANCED = '#4ecdc4';
        
        // Variables de estado
        let grid = [];
        let startNode = null;
        let endNode = null;
        let isDrawing = false;
        let isErasing = false;
        let animationSpeed = 15;
        let dijkstraAnimation = [];
        let astarAnimation = [];
        let enhancedAnimation = [];
        let dijkstraPath = [];
        let astarPath = [];
        let enhancedPath = [];
        let dijkstraVisitedCount = 0;
        let astarVisitedCount = 0;
        let enhancedVisitedCount = 0;
        let dijkstraTime = 0;
        let astarTime = 0;
        let enhancedTime = 0;
        let animationRunning = false;
        
        // Inicialización
        document.addEventListener('DOMContentLoaded', () => {
            createGrid();
            setupEventListeners();
            updateSpeed();
        });
        
        // Crear la cuadrícula
        function createGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            grid = [];
            
            for (let row = 0; row < ROWS; row++) {
                grid[row] = [];
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    gridElement.appendChild(cell);
                    grid[row][col] = {
                        row,
                        col,
                        isStart: false,
                        isEnd: false,
                        isWall: false,
                        element: cell
                    };
                }
            }
            
            // Establecer nodos iniciales
            startNode = grid[5][5];
            endNode = grid[ROWS - 6][COLS - 6];
            startNode.isStart = true;
            endNode.isEnd = true;
            
            updateCellAppearance(startNode);
            updateCellAppearance(endNode);
        }
        
        // Configurar event listeners
        function setupEventListeners() {
            const gridElement = document.getElementById('grid');
            gridElement.addEventListener('mousedown', handleMouseDown);
            gridElement.addEventListener('mouseover', handleMouseOver);
            gridElement.addEventListener('mouseup', handleMouseUp);
            
            document.getElementById('startBtn').addEventListener('click', startVisualization);
            document.getElementById('clearBtn').addEventListener('click', clearGrid);
            document.getElementById('clearWallsBtn').addEventListener('click', clearWalls);
            document.getElementById('randomBtn').addEventListener('click', generateRandomWalls);
            
            document.getElementById('speedSlider').addEventListener('input', updateSpeed);
        }
        
        // Manejar evento mouse down
        function handleMouseDown(e) {
            if (animationRunning) return;
            
            const cell = getCellFromEvent(e);
            if (!cell) return;
            
            if (e.button === 0) { // Clic izquierdo
                if (!cell.isStart && !cell.isEnd) {
                    if (startNode) {
                        startNode.isStart = false;
                        updateCellAppearance(startNode);
                    }
                    
                    cell.isStart = true;
                    cell.isWall = false;
                    startNode = cell;
                    updateCellAppearance(cell);
                }
            } else if (e.button === 2) { // Clic derecho
                if (!cell.isStart && !cell.isEnd) {
                    if (endNode) {
                        endNode.isEnd = false;
                        updateCellAppearance(endNode);
                    }
                    
                    cell.isEnd = true;
                    cell.isWall = false;
                    endNode = cell;
                    updateCellAppearance(cell);
                }
            }
            
            if (!cell.isStart && !cell.isEnd) {
                isDrawing = true;
                cell.isWall = !cell.isWall;
                updateCellAppearance(cell);
            }
        }
        
        function handleMouseOver(e) {
            if (!isDrawing || animationRunning) return;
            
            const cell = getCellFromEvent(e);
            if (!cell || cell.isStart || cell.isEnd) return;
            
            cell.isWall = true;
            updateCellAppearance(cell);
        }
        
        function handleMouseUp() {
            isDrawing = false;
        }
        
        function getCellFromEvent(e) {
            const element = e.target;
            if (!element.classList.contains('cell')) return null;
            
            const row = parseInt(element.dataset.row);
            const col = parseInt(element.dataset.col);
            return grid[row][col];
        }
        
        function updateCellAppearance(cell) {
            cell.element.className = 'cell';
            
            if (cell.isStart) cell.element.classList.add('start');
            if (cell.isEnd) cell.element.classList.add('end');
            if (cell.isWall) cell.element.classList.add('wall');
        }
        
        function updateSpeed() {
            const slider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            animationSpeed = parseInt(slider.value);
            
            const speeds = ['Muy lento', 'Lento', 'Normal', 'Rápido', 'Muy rápido'];
            const speedIndex = Math.min(Math.floor(animationSpeed / 4), 4);
            speedValue.textContent = speeds[speedIndex];
        }
        
        function clearGrid() {
            if (animationRunning) return;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = grid[row][col];
                    cell.isStart = false;
                    cell.isEnd = false;
                    cell.isWall = false;
                    updateCellAppearance(cell);
                }
            }
            
            startNode = grid[5][5];
            endNode = grid[ROWS - 6][COLS - 6];
            startNode.isStart = true;
            endNode.isEnd = true;
            
            updateCellAppearance(startNode);
            updateCellAppearance(endNode);
            
            resetResults();
        }
        
        function clearWalls() {
            if (animationRunning) return;
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = grid[row][col];
                    if (cell.isWall) {
                        cell.isWall = false;
                        updateCellAppearance(cell);
                    }
                }
            }
        }
        
        function generateRandomWalls() {
            if (animationRunning) return;
            
            clearWalls();
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = grid[row][col];
                    if (!cell.isStart && !cell.isEnd && Math.random() < 0.25) {
                        cell.isWall = true;
                        updateCellAppearance(cell);
                    }
                }
            }
        }
        
        function resetResults() {
            document.getElementById('dijkstraTime').textContent = '0 ms';
            document.getElementById('dijkstraVisited').textContent = '0';
            document.getElementById('dijkstraLength').textContent = '0';
            
            document.getElementById('astarTime').textContent = '0 ms';
            document.getElementById('astarVisited').textContent = '0';
            document.getElementById('astarLength').textContent = '0';
            
            document.getElementById('enhancedTime').textContent = '0 ms';
            document.getElementById('enhancedVisited').textContent = '0';
            document.getElementById('enhancedLength').textContent = '0';
            
            document.getElementById('comparison').textContent = '';
            
            document.getElementById('dijkstraResult').classList.remove('winner');
            document.getElementById('astarResult').classList.remove('winner');
            document.getElementById('enhancedResult').classList.remove('winner');
        }
        
        function startVisualization() {
            if (animationRunning || !startNode || !endNode) return;
            
            resetGrid();
            resetResults();
            
            // Ejecutar los tres algoritmos
            runDijkstra();
            runAStar();
            runEnhancedDijkstra();
            
            // Mostrar tiempos inmediatamente
            document.getElementById('dijkstraTime').textContent = `${dijkstraTime.toFixed(2)} ms`;
            document.getElementById('astarTime').textContent = `${astarTime.toFixed(2)} ms`;
            document.getElementById('enhancedTime').textContent = `${enhancedTime.toFixed(2)} ms`;
            
            // Iniciar animación
            animationRunning = true;
            document.getElementById('startBtn').disabled = true;
            
            animateAlgorithms();
        }
        
        function resetGrid() {
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = grid[row][col];
                    if (!cell.isStart && !cell.isEnd && !cell.isWall) {
                        cell.element.className = 'cell';
                    }
                }
            }
        }
        
        // Dijkstra clásico
        function runDijkstra() {
            const startTime = performance.now();
            
            const distances = Array(ROWS).fill().map(() => Array(COLS).fill(Infinity));
            const prevNodes = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            const visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            const queue = [];
            
            distances[startNode.row][startNode.col] = 0;
            queue.push({ node: startNode, distance: 0 });
            
            dijkstraAnimation = [];
            dijkstraVisitedCount = 0;
            
            while (queue.length > 0) {
                queue.sort((a, b) => a.distance - b.distance);
                const current = queue.shift();
                const currentNode = current.node;
                
                if (visited[currentNode.row][currentNode.col]) continue;
                
                visited[currentNode.row][currentNode.col] = true;
                dijkstraVisitedCount++;
                
                if (!currentNode.isStart && !currentNode.isEnd) {
                    dijkstraAnimation.push(currentNode);
                }
                
                if (currentNode === endNode) break;
                
                const neighbors = getNeighbors(currentNode);
                
                for (const neighbor of neighbors) {
                    if (visited[neighbor.row][neighbor.col] || neighbor.isWall) continue;
                    
                    const newDistance = distances[currentNode.row][currentNode.col] + 1;
                    
                    if (newDistance < distances[neighbor.row][neighbor.col]) {
                        distances[neighbor.row][neighbor.col] = newDistance;
                        prevNodes[neighbor.row][neighbor.col] = currentNode;
                        queue.push({ node: neighbor, distance: newDistance });
                    }
                }
            }
            
            dijkstraPath = reconstructPath(prevNodes, startNode, endNode);
            dijkstraTime = performance.now() - startTime;
        }
        
        // A* Search
        function runAStar() {
            const startTime = performance.now();
            
            const gScores = Array(ROWS).fill().map(() => Array(COLS).fill(Infinity));
            const fScores = Array(ROWS).fill().map(() => Array(COLS).fill(Infinity));
            const prevNodes = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            const openSet = [];
            const closedSet = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            
            gScores[startNode.row][startNode.col] = 0;
            fScores[startNode.row][startNode.col] = heuristic(startNode, endNode);
            openSet.push({ node: startNode, fScore: fScores[startNode.row][startNode.col] });
            
            astarAnimation = [];
            astarVisitedCount = 0;
            
            while (openSet.length > 0) {
                openSet.sort((a, b) => a.fScore - b.fScore);
                const current = openSet.shift();
                const currentNode = current.node;
                
                if (currentNode === endNode) break;
                
                closedSet[currentNode.row][currentNode.col] = true;
                astarVisitedCount++;
                
                if (!currentNode.isStart && !currentNode.isEnd) {
                    astarAnimation.push(currentNode);
                }
                
                const neighbors = getNeighbors(currentNode);
                
                for (const neighbor of neighbors) {
                    if (neighbor.isWall || closedSet[neighbor.row][neighbor.col]) continue;
                    
                    const tentativeGScore = gScores[currentNode.row][currentNode.col] + 1;
                    
                    if (tentativeGScore < gScores[neighbor.row][neighbor.col]) {
                        prevNodes[neighbor.row][neighbor.col] = currentNode;
                        gScores[neighbor.row][neighbor.col] = tentativeGScore;
                        fScores[neighbor.row][neighbor.col] = tentativeGScore + heuristic(neighbor, endNode);
                        
                        if (!openSet.some(item => item.node === neighbor)) {
                            openSet.push({ 
                                node: neighbor, 
                                fScore: fScores[neighbor.row][neighbor.col] 
                            });
                        }
                    }
                }
            }
            
            astarPath = reconstructPath(prevNodes, startNode, endNode);
            astarTime = performance.now() - startTime;
        }
        
        // BMSSP - Implementación basada en arXiv:2504.17033
        function runEnhancedDijkstra() {
            const startTime = performance.now();
            
            const distances = Array(ROWS).fill().map(() => Array(COLS).fill(Infinity));
            const prevNodes = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            const visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            
            // Bucketed priority queue - key optimization
            const maxDistance = ROWS + COLS;
            const bucketSize = Math.ceil(Math.pow(maxDistance, 2/3));
            const buckets = Array(bucketSize).fill().map(() => []);
            let currentBucket = 0;
            let minDistance = 0;
            
            distances[startNode.row][startNode.col] = 0;
            buckets[0].push(startNode);
            
            enhancedAnimation = [];
            enhancedVisitedCount = 0;
            
            // Region-based processing optimization
            const processedRegions = new Set();
            const regionSize = 8;
            
            while (currentBucket < bucketSize) {
                // Process current bucket
                while (buckets[currentBucket].length > 0) {
                    const currentNode = buckets[currentBucket].shift();
                    
                    if (visited[currentNode.row][currentNode.col]) continue;
                    
                    visited[currentNode.row][currentNode.col] = true;
                    enhancedVisitedCount++;
                    
                    if (!currentNode.isStart && !currentNode.isEnd) {
                        enhancedAnimation.push(currentNode);
                    }
                    
                    if (currentNode === endNode) break;
                    
                    // Batch processing for region optimization
                    const regionKey = `${Math.floor(currentNode.row / regionSize)}-${Math.floor(currentNode.col / regionSize)}`;
                    const neighbors = getNeighbors(currentNode);
                    
                    // Enhanced neighbor processing with region awareness
                    const regionNeighbors = [];
                    const outsideNeighbors = [];
                    
                    for (const neighbor of neighbors) {
                        if (visited[neighbor.row][neighbor.col] || neighbor.isWall) continue;
                        
                        const neighborRegion = `${Math.floor(neighbor.row / regionSize)}-${Math.floor(neighbor.col / regionSize)}`;
                        if (neighborRegion === regionKey) {
                            regionNeighbors.push(neighbor);
                        } else {
                            outsideNeighbors.push(neighbor);
                        }
                    }
                    
                    // Process region neighbors with priority
                    const allNeighbors = [...regionNeighbors, ...outsideNeighbors];
                    
                    for (const neighbor of allNeighbors) {
                        const newDistance = distances[currentNode.row][currentNode.col] + 1;
                        
                        if (newDistance < distances[neighbor.row][neighbor.col]) {
                            distances[neighbor.row][neighbor.col] = newDistance;
                            prevNodes[neighbor.row][neighbor.col] = currentNode;
                            
                            // Smart bucketing with logarithmic distribution
                            const bucketIndex = Math.min(
                                Math.floor(newDistance * bucketSize / maxDistance),
                                bucketSize - 1
                            );
                            
                            buckets[bucketIndex].push(neighbor);
                        }
                    }
                    
                    processedRegions.add(regionKey);
                }
                
                // Move to next non-empty bucket
                currentBucket++;
                while (currentBucket < bucketSize && buckets[currentBucket].length === 0) {
                    currentBucket++;
                }
            }
            
            enhancedPath = reconstructPath(prevNodes, startNode, endNode);
            enhancedTime = performance.now() - startTime;
        }
        
        function heuristic(nodeA, nodeB) {
            return Math.abs(nodeA.row - nodeB.row) + Math.abs(nodeA.col - nodeB.col);
        }
        
        function getNeighbors(node) {
            const neighbors = [];
            const directions = [
                { row: -1, col: 0 },
                { row: 1, col: 0 },
                { row: 0, col: -1 },
                { row: 0, col: 1 }
            ];
            
            for (const dir of directions) {
                const newRow = node.row + dir.row;
                const newCol = node.col + dir.col;
                
                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                    neighbors.push(grid[newRow][newCol]);
                }
            }
            
            return neighbors;
        }
        
        function reconstructPath(prevNodes, startNode, endNode) {
            const path = [];
            let currentNode = endNode;
            
            while (currentNode !== null && currentNode !== startNode) {
                path.unshift(currentNode);
                currentNode = prevNodes[currentNode.row][currentNode.col];
            }
            
            return path;
        }
        
        function animateAlgorithms() {
            const dijkstraCells = [...dijkstraAnimation];
            const astarCells = [...astarAnimation];
            const enhancedCells = [...enhancedAnimation];
            
            const dijkstraPathCells = [...dijkstraPath];
            const astarPathCells = [...astarPath];
            const enhancedPathCells = [...enhancedPath];
            
            let dijkstraPathStarted = false;
            let astarPathStarted = false;
            let enhancedPathStarted = false;
            
            function animateStep() {
                // Animar Dijkstra
                if (dijkstraCells.length > 0) {
                    const cell = dijkstraCells.shift();
                    if (!cell.isStart && !cell.isEnd) {
                        cell.element.classList.add('visited', 'dijkstra');
                    }
                } else if (!dijkstraPathStarted) {
                    dijkstraPathStarted = true;
                    animatePath(dijkstraPathCells, 'dijkstra');
                }
                
                // Animar A*
                if (astarCells.length > 0) {
                    const cell = astarCells.shift();
                    if (!cell.isStart && !cell.isEnd) {
                        cell.element.classList.add('visited', 'astar');
                    }
                } else if (!astarPathStarted) {
                    astarPathStarted = true;
                    animatePath(astarPathCells, 'astar');
                }
                
                // Animar BMSSP
                if (enhancedCells.length > 0) {
                    const cell = enhancedCells.shift();
                    if (!cell.isStart && !cell.isEnd) {
                        cell.element.classList.add('visited', 'enhanced');
                    }
                } else if (!enhancedPathStarted) {
                    enhancedPathStarted = true;
                    animatePath(enhancedPathCells, 'enhanced');
                }
                
                // Verificar si todos los algoritmos han terminado
                if (dijkstraPathStarted && astarPathStarted && enhancedPathStarted) {
                    // Actualizar resultados
                    document.getElementById('dijkstraVisited').textContent = dijkstraVisitedCount;
                    document.getElementById('dijkstraLength').textContent = dijkstraPath.length;
                    
                    document.getElementById('astarVisited').textContent = astarVisitedCount;
                    document.getElementById('astarLength').textContent = astarPath.length;
                    
                    document.getElementById('enhancedVisited').textContent = enhancedVisitedCount;
                    document.getElementById('enhancedLength').textContent = enhancedPath.length;
                    
                    // Determinar ganador
                    let winnerText = '';
                    const paths = [
                        { name: 'Dijkstra', length: dijkstraPath.length, element: 'dijkstraResult' },
                        { name: 'A*', length: astarPath.length, element: 'astarResult' },
                        { name: 'Enhanced', length: enhancedPath.length, element: 'enhancedResult' }
                    ];
                    
                    const validPaths = paths.filter(p => p.length > 0);
                    
                    if (validPaths.length > 0) {
                        const minLength = Math.min(...validPaths.map(p => p.length));
                        const winners = validPaths.filter(p => p.length === minLength);
                        
                        if (winners.length === 1) {
                            winnerText = `${winners[0].name} encontró el camino más corto (${minLength})`;
                            document.getElementById(winners[0].element).classList.add('winner');
                        } else {
                            const winnerNames = winners.map(w => w.name).join(', ');
                            winnerText = `Empate entre ${winnerNames} (longitud ${minLength})`;
                            winners.forEach(w => document.getElementById(w.element).classList.add('winner'));
                        }
                        
                        // Agregar información sobre eficiencia
                        const minVisited = Math.min(dijkstraVisitedCount, astarVisitedCount, enhancedVisitedCount);
                        const mostEfficient = [
                            { name: 'Dijkstra', visited: dijkstraVisitedCount },
                            { name: 'A*', visited: astarVisitedCount },
                            { name: 'Enhanced', visited: enhancedVisitedCount }
                        ].find(a => a.visited === minVisited);
                        
                        winnerText += ` | ${mostEfficient.name} fue el más eficiente (${minVisited} celdas visitadas)`;
                    } else {
                        winnerText = 'Ningún algoritmo encontró un camino';
                    }
                    
                    document.getElementById('comparison').textContent = winnerText;
                    
                    // Restablecer estado
                    animationRunning = false;
                    document.getElementById('startBtn').disabled = false;
                    return;
                }
                
                // Continuar animación
                setTimeout(animateStep, 50 - (animationSpeed * 2));
            }
            
            animateStep();
        }
        
        function animatePath(path, algoType) {
            if (path.length === 0) return;
            
            let i = 0;
            function animateStep() {
                if (i < path.length) {
                    const cell = path[i];
                    if (!cell.isStart && !cell.isEnd) {
                        cell.element.className = 'cell';
                        cell.element.classList.add('path', algoType);
                    }
                    i++;
                    setTimeout(animateStep, 20);
                }
            }
            
            animateStep();
        }
        
        // Prevenir menú contextual en clic derecho
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
